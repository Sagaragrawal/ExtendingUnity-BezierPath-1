<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Extending Unity - Bézier Path: Tutorial 1 by TobiasKullblikk</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Extending Unity - Bézier Path: Tutorial 1</h1>
      <h2 class="project-tagline">Project overview and implementing the basic features</h2>
      <a href="https://github.com/TobiasKullblikk/ExtendingUnity-BezierPath-1" class="btn">View on GitHub</a>
      <a href="https://github.com/TobiasKullblikk/ExtendingUnity-BezierPath-1/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/TobiasKullblikk/ExtendingUnity-BezierPath-1/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>

<p>Unity is well known for its Asset Store and the vast amount of resources available there. Anyone can download tools to simplify the production of their games. Many tools have custom editors for managing the data related to it. Wouldn't it be great to be able to make tools like this ourselves?</p>

<p>Unity offers an API for extending the editor through scripts in your project. Throughout the parts of this guide, we will learn to master this power and become a Wizard of Unity. We'll take a closer look at interacting with points in the scene using Handles, building custom interfaces for the SceneView and customizing the InspectorView to our liking.</p>

<p>This guide will focus on learning you the good habits and guidelines around the process of building tools for Unity and is targeted at intermediate developers. You will not see me comment on how the basics of our code works. However, you will get a (hopefully) clear introduction to how the logic behind Bézier Curves work and how we implement it.</p>

<h3>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h3>

<p>Bézier Curves are used to generate smooth curves from a given set of control points. The curves will always start with the same position as the first control point and end at the position of the last. Bézier Curves are popular in computer software as they are easy to implement, easy to use and the quality of the curves can be scaled indefinitely.</p>

<p>Bézier Curves are classified by its order, that is, by how many control points it uses. When working with Bézier Curves in computer software, you are most likely using Cubic Bézier Curves. These curves are of the 4th order, meaning they consists of 4 control points. The following animation illustrates how the value <em>t</em>, ranging from 0.0 to 1.0, can be used to retrieve any position along the Cubic Bézier Curve. Here we have control points 0 &amp; 3 acting as endpoints, while control points 1 &amp; 2 acts like magnetic forces attracting the curve.</p>

<p><img src="https://i.gyazo.com/f7982ce558d0c3fdfd3d22fe2b9e18a0.gif" alt=""></p>

<p>To make our BezierPath, we simply combine several Cubic Bézier Curves in a continuous sequence like demonstrated in the illustration below. Note that control points 1 &amp; 2 (Handles) are only visible when connected to a point that is selected. </p>

<p><img src="https://i.gyazo.com/0033536b408c34598c5c438afa09de57.gif" alt=""></p>

<p>Each BezierPoint will store cached positions for the points generated between the current BezierPoint and the one indexed above it. This list of cached points will be named 'points' in the BezierPoint class. The list will also contain the current BezierPoint position as the first element, and the position of the BezierPoint indexed above it as the last element.</p>

<p><img src="https://i.gyazo.com/05e11314ccdd7583ed967f90aeeef3dd.png" alt=""></p>

<p>When building scripts for the editor, it's important to keep performance in mind. You don't want your tools to be chewing off all the resources Unity and your system has to offer. Seeing how Bézier Curves work, it becomes obvious to us that when a point is being modified, only the connected 'parts' of the path will be affected. We will use this information to narrow down what parts of the BezierPath needs to be regenerated when. While Unity is fully capable of regenerating the whole curve every frame, you never want to use more resources than what is strictly necessary.</p>

<h3>
<a id="bezierpoint" class="anchor" href="#bezierpoint" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BezierPoint</h3>

<p>For the BezierPoint class, we are going to store all the information that has to do with each induvidual BezierPoint.</p>

<ul>
<li>Position of the BezierPoint.</li>
<li>Position of the back and front handle, both with origin at the position of the BezierPoint.</li>
<li>ArmMode, controlling the handle behaviour.</li>
<li>Iterations, the number of points added between this BezierPoint and the next.</li>
<li>List of cached points.</li>
<li>List of lengths between cached points.</li>
<li>Total length.</li>
</ul>

<p>Let's make a new C# script <em>"Assets\BezierPath\BezierPoint.cs"</em> and fill it with the following code, code-discussion follows after:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> UnityEngine<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Collections.Generic<span class="pl-k">;</span>

[System.Serializable]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">BezierPoint</span>
{
    <span class="pl-c">// TODO: Make handles act according to current ArmMode in the 'set' accessors</span>
    <span class="pl-k">public</span> Vector3 <span class="pl-en">handleBack</span> { <span class="pl-k">get</span> { <span class="pl-k">return</span> _handleBack; } <span class="pl-k">set</span> { _handleBack = <span class="pl-k">value</span>; } }
    <span class="pl-k">public</span> Vector3 <span class="pl-en">handleFront</span> { <span class="pl-k">get</span> { <span class="pl-k">return</span> _handleFront; } <span class="pl-k">set</span> { _handleFront = <span class="pl-k">value</span>; } }

    <span class="pl-k">public</span> Vector3 position;
    <span class="pl-k">public</span> List&lt;Vector3&gt; points = <span class="pl-k">new</span> List&lt;Vector3&gt;();
    <span class="pl-k">public</span> List&lt;<span class="pl-k">float</span>&gt; lengths = <span class="pl-k">new</span> List&lt;<span class="pl-k">float</span>&gt;();
    <span class="pl-k">public</span> <span class="pl-k">float</span> length = <span class="pl-c1">0</span>;
    <span class="pl-k">public</span> <span class="pl-k">int</span> iterations;
    <span class="pl-k">public</span> ArmMode armMode;

    [SerializeField]
    <span class="pl-k">private</span> Vector3 _handleBack, _handleFront;

    <span class="pl-k">public</span> <span class="pl-en">BezierPoint</span>(<span class="pl-k">Vector3</span> <span class="pl-smi">pos</span>, <span class="pl-k">Vector3</span> <span class="pl-smi">_handleB</span>, <span class="pl-k">Vector3</span> <span class="pl-smi">_handleF</span>, <span class="pl-k">int</span> <span class="pl-smi">iter</span>, <span class="pl-k">ArmMode</span> <span class="pl-smi">armM</span>)
    {
        position = pos;
        _handleBack = _handleB;
        _handleFront = _handleF;
        iterations = iter;
        armMode = armM;
    }
}

<span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-en">ArmMode</span>
{
    Mirror,
    MirrorAngle,
    Induvidual
}</pre></div>

<p>Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..</p>

<h3>
<a id="bezierpath" class="anchor" href="#bezierpath" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BezierPath</h3>

<p>The BezierPath class extends MonoBehaviour so that we can use it as a Component with our GameObjects. The most essential data stored in the BezierPath is the list of BezierPoints and the 'closed' variable. The latter specifies if the last BezierPoint will connect to the first one, creating a closed path. The other variables added to the class will be used later on in the guide and are self-explanatory with their names. I also implemented a mathematical Mod method, to help contain the selected index within its bounds. I will talk more about this when implementing the Generate method to the BezierPath class.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> UnityEngine<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Collections.Generic<span class="pl-k">;</span>

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">BezierPath</span> : <span class="pl-k">MonoBehaviour</span>
{
    <span class="pl-c">// TODO: Add length get property, respecting closed paths</span>

    <span class="pl-k">public</span> List&lt;BezierPoint&gt; bezierPoints = <span class="pl-k">new</span> List&lt;BezierPoint&gt;();
    <span class="pl-k">public</span> <span class="pl-k">bool</span> closed = <span class="pl-c1">false</span>;
    <span class="pl-k">public</span> <span class="pl-k">bool</span> hideTransform = <span class="pl-c1">false</span>, freeHandle = <span class="pl-c1">true</span>, dialogOpen = <span class="pl-c1">true</span>;
    <span class="pl-k">public</span> Color color = Color.white, colorSelected = Color.red;
    <span class="pl-k">public</span> <span class="pl-k">float</span> sizePosition = <span class="pl-c1">0.25f</span>, sizeHandle = <span class="pl-c1">0.15f</span>;

    <span class="pl-k">private</span> <span class="pl-k">float</span> _length = <span class="pl-c1">0</span>;

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">int</span> <span class="pl-en">Mod</span>(<span class="pl-k">int</span> <span class="pl-smi">a</span>, <span class="pl-k">int</span> <span class="pl-smi">b</span>)
    {
        <span class="pl-k">return</span> a - b * (<span class="pl-k">int</span>)Mathf.Floor(a / (<span class="pl-k">float</span>)b);
    }
}</pre></div>

<h3>
<a id="point-iteration" class="anchor" href="#point-iteration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Point Iteration</h3>

<p><img src="https://upload.wikimedia.org/math/2/c/7/2c7967667f039ce77d8984f5e4cd088c.png" alt=""></p>

<p>It is always important to break your software into small manageable modules. The first method we will be implementing is the Cubic Bézier Curve formula. It will take 4 control points and a value <em>t</em> between 0.0 and 1.0. The method is identical to the formula. I made the method static so that it is ready to be used for purposes other than this exact tool. It was added to the BezierPoint class as it is the class handling the cached points.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">static</span> Vector3 CalculateBezier(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, <span class="pl-k">float</span> t)
{
    <span class="pl-k">return</span> (Mathf.Pow(<span class="pl-c1">1</span> - t, <span class="pl-c1">3</span>) * p0) + (<span class="pl-c1">3</span> * Mathf.Pow(<span class="pl-c1">1</span> - t, <span class="pl-c1">2</span>) * t * p1) + (<span class="pl-c1">3</span> * (<span class="pl-c1">1</span> - t) * t * t * p2) + (t * t * t * p3);
}</pre></div>

<p>Next we are going to make the method generating all the points between two BezierPoints. We are going to add this method to the BezierPoint class as well. It will be executed from one BezierPoint and taking another as an argument. All cache for the BezierPoint executing the method will be regenerated. For each loop-cycle, we increment the value <em>t</em> and add the associated point to the cache. Lengths are calculated and stored as well. Notice how the for-loop is bound to always run at least two times. This is to always include the endpoints (where t == 0.0 or t == 1.0).</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">void</span> IterateBezierPoints(BezierPoint bezierPoint)
{
    points.Clear();
    lengths.Clear();
    length = <span class="pl-c1">0</span>;

    Vector3 point_0 = position;
    Vector3 point_1 = point_0 + handleFront;
    Vector3 point_3 = bezierPoint.position;
    Vector3 point_2 = point_3 + bezierPoint.handleBack;

    <span class="pl-k">for</span> (<span class="pl-k">int</span> iteration = <span class="pl-c1">0</span>; iteration &lt;= iterations + <span class="pl-c1">1</span>; iteration++)
    {
        points.Add(CalculateBezier(point_0, point_1, point_2, point_3, ((<span class="pl-k">float</span>)iteration) / (<span class="pl-k">float</span>)(iterations + <span class="pl-c1">1</span>)));
        <span class="pl-k">if</span> (iteration != <span class="pl-c1">0</span>)
        { lengths.Add(Vector3.Distance(points[iteration - <span class="pl-c1">1</span>], points[iteration])); length += lengths[lengths.Count - <span class="pl-c1">1</span>]; }
    }
}</pre></div>

<p>This next piece of code will be addded to the BezierPath class. It will update the curve in front of the BezierPoint and the curve behind it (The BezierPoint indexed below). We also recalculate our length, but dont include the last curve as it is the closing gap and will be included later when making the length property. We use the Mod method to wrap the index to keep it within the allowed indexes. Remember that this is the mathematical Modulo and therefore works differently than the (%)-operator.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">void</span> Generate(<span class="pl-k">int</span> index)
{
    <span class="pl-k">if</span> (bezierPoints.Count &gt; <span class="pl-c1">0</span>)
    {
        bezierPoints[index].IterateBezierPoints(bezierPoints[Mod(index + <span class="pl-c1">1</span>, bezierPoints.Count)]);
        bezierPoints[Mod(index - <span class="pl-c1">1</span>, bezierPoints.Count)].IterateBezierPoints(bezierPoints[index]);
    }

    _length = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; bezierPoints.Count - <span class="pl-c1">1</span>; i++)
        _length += bezierPoints[i].length;
}</pre></div>

<p>Nice ! Now we have our basic implementation of the BezierPath logic completed, but we still can't see anything in our SceneView. Let's do something about that!</p>

<h3>
<a id="displaying-the-path" class="anchor" href="#displaying-the-path" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Displaying the path</h3>

<p>Create a new C# script <em>"Assets\BezierPath\Editor\BezierPathEditor.cs"</em>. It was placed in a folder named "Editor" so that Unity will treat it like an editor script. Inside the script, we include the UnityEditor to get access to the Editor API. Our class extends the Editor so that it will get access to the Editor functionalities. The class has also been tagged as a CustomEditor of the type BezierPath, meaning it will be used when a GameObject with a BezierPath Component attached is selected.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> UnityEngine<span class="pl-k">;</span>
<span class="pl-k">using</span> UnityEditor<span class="pl-k">;</span>

[CustomEditor(<span class="pl-k">typeof</span>(BezierPath))]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">BezierPathEditor</span> : <span class="pl-k">Editor</span>
{
    <span class="pl-k">private</span> BezierPath bezierPath;
}</pre></div>

<p>gfgdfgdfg, rtuy.. ttuyu ...</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">private</span> <span class="pl-k">void</span> DrawBezierPath()
{
    <span class="pl-k">for</span> (<span class="pl-k">int</span> bezierPointNumber = <span class="pl-c1">0</span>; bezierPointNumber &lt; bezierPath.bezierPoints.Count - (bezierPath.closed ? <span class="pl-c1">0</span> : <span class="pl-c1">1</span>); bezierPointNumber++)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> iteration = <span class="pl-c1">0</span>; iteration &lt; bezierPath.bezierPoints[bezierPointNumber].iterations + <span class="pl-c1">1</span>; iteration++)
            Handles.DrawLine(bezierPath.transform.TransformPoint(bezierPath.bezierPoints[bezierPointNumber].points[iteration]),
                bezierPath.transform.TransformPoint(bezierPath.bezierPoints[bezierPointNumber].points[iteration + <span class="pl-c1">1</span>]));
    }
}</pre></div>

<h3>
<a id="stay-tuned" class="anchor" href="#stay-tuned" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stay tuned!</h3>

<p>For more guides blablablablablabla... Tobias Kullblikk</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/TobiasKullblikk/ExtendingUnity-BezierPath-1">Extending Unity - Bézier Path: Tutorial 1</a> is maintained by <a href="https://github.com/TobiasKullblikk">TobiasKullblikk</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
