{
  "name": "Extending Unity - Bézier Path: Tutorial 1",
  "tagline": "Project overview and implementing the basic features",
  "body": "### Introduction\r\nUnity is well known for its Asset Store and the vast amount of resources available there. Anyone can download tools to simplify the production of their games. Many tools have custom editors for managing the data related to it. Wouldn't it be great to be able to make tools like this ourselves?\r\n\r\nUnity offers an extensive API for extending the editor through scripts in your project. Throughout the parts of this guide, we will learn to master this power and become a Wizard of Unity. We'll take a closer look at interacting with points in the scene using Handles, building custom interfaces for the SceneView and customizing the InspectorView to our liking.\r\n\r\n### Overview\r\nBézier Curves are used to generate smooth curves from a given set of control points. The curves will always start with the same position as the first control point and end at the position of the last. Bézier Curves are popular in computer software as they are easy to implement, easy to use and the quality of the curves can be scaled indefinitely.\r\n\r\nBézier Curves are classified by its order, that is, by how many control points it uses. When working with Bézier Curves in computer software, you are most likely using Cubic Bézier Curves. These curves are of the 4th order, meaning they consists of 4 control points. The following animation illustrates how the value _t_, ranging from 0.0 to 1.0, can be used to retrieve any position along the Cubic Bézier Curve. Here we have control points 0 & 3 acting as endpoints, while control points 1 & 2 acts like magnetic forces attracting the curve.\r\n\r\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/B%C3%A9zier_3_big.gif/240px-B%C3%A9zier_3_big.gif)\r\n![](https://upload.wikimedia.org/math/2/c/7/2c7967667f039ce77d8984f5e4cd088c.png)\r\n\r\nTo make our BezierPath, we simply combine several Cubic Bézier Curves in a continuous sequence like demonstrated in the illustration below. Note that control points 1 & 2 are only visible when connected to a point that is selected. \r\n\r\n![](https://i.gyazo.com/0033536b408c34598c5c438afa09de57.gif)\r\n\r\nEach BezierPoint will store cached positions for the points generated between the current BezierPoint and the one indexed above it. This list of cached points will be named 'points' in the BezierPoint class. The list will also contain the current BezierPoint position as the first element, and the position of the BezierPoint indexed above it as the last element.\r\n\r\n![](https://i.gyazo.com/05e11314ccdd7583ed967f90aeeef3dd.png)\r\n\r\nWhen building scripts for the editor, it's important to keep performance in mind. You don't want your tools to be chewing off all the resources Unity and your system has to offer. Seeing how Bézier Curves work, it becomes obvious to us that when a point is being modified, only the connected 'parts' of the path will be affected. We will use this information to narrow down what parts of the BezierPath needs to be regenerated when. While Unity is fully capable of regenerating the whole curve every frame, you never want to use more resources than what is strictly necessary.\r\n\r\n### BezierPoint\r\nFor the BezierPoint Class, we are going to store all the information that has to do with each induvidual BezierPoint.\r\n* Position of the BezierPoint\r\n* Position of the back and front handle (both with origin at the position of the BezierPoint)\r\n* ArmMode controlling the handle behaviour\r\n* Iterations\r\n* List of cached points\r\n* List of lengths between cached points\r\n* Total length\r\n\r\nLet's make a new C# script _\"Assets\\BezierPath\\BezierPoint.cs\"_ and fill it with the following code, code-discussion follows after:\r\n\r\n```cs\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n[System.Serializable]\r\npublic class BezierPoint\r\n{\r\n    // TODO: Make handles act according to current ArmMode in the 'set' accessors\r\n    public Vector3 handleBack { get; set; }\r\n    public Vector3 handleFront { get; set; }\r\n\r\n    public Vector3 position;\r\n    public List<Vector3> points = new List<Vector3>();\r\n    public List<float> lengths = new List<float>();\r\n    public float length = 0;\r\n    public int iterations;\r\n    public ArmMode armMode;\r\n\r\n    [SerializeField]\r\n    private Vector3 _handleBack, _handleFront;\r\n\r\n    public BezierPoint(Vector3 pos, Vector3 _handleB, Vector3 _handleF, int iter, ArmMode armM)\r\n    {\r\n        position = pos;\r\n        _handleBack = _handleB;\r\n        _handleFront = _handleF;\r\n        iterations = iter;\r\n        armMode = armM;\r\n    }\r\n}\r\n\r\npublic enum ArmMode\r\n{\r\n    Mirror,\r\n    MirrorAngle,\r\n    Induvidual\r\n}\r\n```\r\n\r\n### Point Iteration\r\n\r\n### BezierPath\r\n\r\n### Displaying the path",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}