{
  "name": "Extending Unity - Bézier Path: Tutorial 1",
  "tagline": "Project overview and implementing the basic features",
  "body": "### Introduction\r\nUnity is well known for its Asset Store and the vast amount of resources available there. Anyone can download tools to simplify the production of their games. Many tools have custom editors for managing the data related to it. Wouldn't it be great to be able to make tools like this ourselves?\r\n\r\nUnity offers an API for extending the editor through scripts in your project. Throughout the parts of this guide, we will learn to master this power and become a Wizard of Unity. We'll take a closer look at interacting with points in the scene using Handles, building custom interfaces for the SceneView and customizing the InspectorView to our liking.\r\n\r\nThis guide will focus on learning you the good habits and guidelines around the process of building tools for Unity and is targeted at intermediate developers. You will not see me comment on how the basics of our code works. However, you will get a (hopefully) clear introduction to how the logic behind Bézier Curves work and how we implement it.\r\n\r\n### Overview\r\nBézier Curves are used to generate smooth curves from a given set of control points. The curves will always start with the same position as the first control point and end at the position of the last. Bézier Curves are popular in computer software as they are easy to implement, easy to use and the quality of the curves can be scaled indefinitely.\r\n\r\nBézier Curves are classified by its order, that is, by how many control points it uses. When working with Bézier Curves in computer software, you are most likely using Cubic Bézier Curves. These curves are of the 4th order, meaning they consists of 4 control points. The following animation illustrates how the value _t_, ranging from 0.0 to 1.0, can be used to retrieve any position along the Cubic Bézier Curve. Here we have control points 0 & 3 acting as endpoints, while control points 1 & 2 acts like magnetic forces attracting the curve. The blue and green lines help visualize how the formula calculates points along the curve.\r\n\r\n![](https://i.gyazo.com/f7982ce558d0c3fdfd3d22fe2b9e18a0.gif)\r\n\r\nTo make our BezierPath, we simply combine several Cubic Bézier Curves in a continuous sequence like demonstrated in the illustration below. Note that control points 1 & 2 (Handles) are only visible when connected to a point that is selected. \r\n\r\n![](https://i.gyazo.com/0033536b408c34598c5c438afa09de57.gif)\r\n\r\nEach BezierPoint will store cached positions for the points generated between the current BezierPoint and the one indexed above it. This list of cached points will be named 'points' in the BezierPoint class. The list will also contain the current BezierPoint position as the first element, and the position of the BezierPoint indexed above it as the last element.\r\n\r\n![](https://i.gyazo.com/05e11314ccdd7583ed967f90aeeef3dd.png)\r\n\r\nWhen building scripts for the editor, it's important to keep performance in mind. You don't want your tools to be chewing off all the resources Unity and your system has to offer. Seeing how Bézier Curves work, it becomes obvious to us that when a point is being modified, only the connected 'parts' of the path will be affected. We will use this information to narrow down what parts of the BezierPath needs to be regenerated when. While Unity is fully capable of regenerating the whole curve every frame, you never want to use more resources than what is strictly necessary.\r\n\r\n### BezierPoint\r\nFor the BezierPoint class, we are going to store all the information that has to do with each induvidual BezierPoint.\r\n* Position of the BezierPoint.\r\n* Position of the back and front handle, both with origin at the position of the BezierPoint.\r\n* ArmMode, controlling the handle behaviour.\r\n* Iterations, the number of points added between this BezierPoint and the next.\r\n* List of cached points.\r\n* List of lengths between cached points.\r\n* Total length.\r\n\r\nLet's make a new C# script _\"Assets\\BezierPath\\BezierPoint.cs\"_ and fill it with the following code, code-discussion follows after:\r\n\r\n```cs\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n[System.Serializable]\r\npublic class BezierPoint\r\n{\r\n    // TODO: Make handles act according to current ArmMode in the 'set' accessors\r\n    public Vector3 handleBack { get { return _handleBack; } set { _handleBack = value; } }\r\n    public Vector3 handleFront { get { return _handleFront; } set { _handleFront = value; } }\r\n\r\n    public Vector3 position;\r\n    public List<Vector3> points = new List<Vector3>();\r\n    public List<float> lengths = new List<float>();\r\n    public float length = 0;\r\n    public int iterations;\r\n    public ArmMode armMode;\r\n\r\n    [SerializeField]\r\n    private Vector3 _handleBack, _handleFront;\r\n\r\n    public BezierPoint(Vector3 pos, Vector3 _handleB, Vector3 _handleF, int iter, ArmMode armM)\r\n    {\r\n        position = pos;\r\n        _handleBack = _handleB;\r\n        _handleFront = _handleF;\r\n        iterations = iter;\r\n        armMode = armM;\r\n    }\r\n}\r\n\r\npublic enum ArmMode\r\n{\r\n    Mirror,\r\n    MirrorAngle,\r\n    Induvidual\r\n}\r\n```\r\nBlablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..Blablablabla talk about the code.. serialize blablabla..\r\n\r\n### BezierPath\r\nThe BezierPath class extends MonoBehaviour so that we can use it as a Component with our GameObjects. The most essential data stored in the BezierPath is the list of BezierPoints and the 'closed' variable. The latter specifies if the last BezierPoint will connect to the first one, creating a closed path. The other variables added to the class will be used later on in the guide and are self-explanatory with their names. I also implemented a mathematical Mod method, to help contain the selected index within its bounds. I will talk more about this when implementing the Generate method to the BezierPath class.\r\n```cs\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\npublic class BezierPath : MonoBehaviour\r\n{\r\n    // TODO: Add length get property, respecting closed paths\r\n\r\n    public List<BezierPoint> bezierPoints = new List<BezierPoint>();\r\n    public bool closed = false;\r\n    public bool hideTransform = false, freeHandle = true, dialogOpen = true;\r\n    public Color color = Color.white, colorSelected = Color.red;\r\n    public float sizePosition = 0.25f, sizeHandle = 0.15f;\r\n\r\n    private float _length = 0;\r\n\r\n    public static int Mod(int a, int b)\r\n    {\r\n        return a - b * (int)Mathf.Floor(a / (float)b);\r\n    }\r\n}\r\n```\r\n\r\n### Point Iteration\r\n![](https://upload.wikimedia.org/math/2/c/7/2c7967667f039ce77d8984f5e4cd088c.png)\r\n\r\nIt is always important to break your software into small manageable modules. The first method we will be implementing is the Cubic Bézier Curve formula. It will take 4 control points and a value _t_ between 0.0 and 1.0. The method is identical to the formula. I made the method static so that it is ready to be used for purposes other than this exact tool. It was added to the BezierPoint class as it is the class handling the cached points.\r\n```cs\r\npublic static Vector3 CalculateBezier(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)\r\n{\r\n    return (Mathf.Pow(1 - t, 3) * p0) + (3 * Mathf.Pow(1 - t, 2) * t * p1) + (3 * (1 - t) * t * t * p2) + (t * t * t * p3);\r\n}\r\n```\r\nNext we are going to make the method generating all the points between two BezierPoints. We are going to add this method to the BezierPoint class as well. It will be executed from one BezierPoint and taking another as an argument. All cache for the BezierPoint executing the method will be regenerated. For each loop-cycle, we increment the value _t_ and add the associated point to the cache. Lengths are calculated and stored as well. Notice how the for-loop is bound to always run at least two times. This is to always include the endpoints (where t == 0.0 or t == 1.0).\r\n```cs\r\npublic void IterateBezierPoints(BezierPoint bezierPoint)\r\n{\r\n    points.Clear();\r\n    lengths.Clear();\r\n    length = 0;\r\n\r\n    Vector3 point_0 = position;\r\n    Vector3 point_1 = point_0 + handleFront;\r\n    Vector3 point_3 = bezierPoint.position;\r\n    Vector3 point_2 = point_3 + bezierPoint.handleBack;\r\n\r\n    for (int iteration = 0; iteration <= iterations + 1; iteration++)\r\n    {\r\n        points.Add(CalculateBezier(point_0, point_1, point_2, point_3, ((float)iteration) / (float)(iterations + 1)));\r\n        if (iteration != 0)\r\n        { lengths.Add(Vector3.Distance(points[iteration - 1], points[iteration])); length += lengths[lengths.Count - 1]; }\r\n    }\r\n}\r\n```\r\nThis next piece of code will be addded to the BezierPath class. It will update the curve in front of the BezierPoint and the curve behind it (The BezierPoint indexed below). We also recalculate our length, but dont include the last curve as it is the closing gap and will be included later when making the length property. We use the Mod method to wrap the index to keep it within the allowed indexes. Remember that this is the mathematical Modulo and therefore works differently than the (%)-operator.\r\n```cs\r\npublic void Generate(int index)\r\n{\r\n    if (bezierPoints.Count > 0)\r\n    {\r\n        bezierPoints[index].IterateBezierPoints(bezierPoints[Mod(index + 1, bezierPoints.Count)]);\r\n        bezierPoints[Mod(index - 1, bezierPoints.Count)].IterateBezierPoints(bezierPoints[index]);\r\n    }\r\n\r\n    _length = 0;\r\n    for (int i = 0; i < bezierPoints.Count - 1; i++)\r\n        _length += bezierPoints[i].length;\r\n}\r\n```\r\nNice ! Now we have our basic implementation of the BezierPath logic completed, but we still can't see anything in our SceneView. Let's do something about that!\r\n\r\n### Displaying the path\r\nCreate a new C# script _\"Assets\\BezierPath\\Editor\\BezierPathEditor.cs\"_. It was placed in a folder named \"Editor\" so that Unity will treat it like an editor script. Inside the script, we include the UnityEditor to get access to the Editor API. Our class extends the Editor so that it will get access to the Editor functionalities. The class has also been tagged as a CustomEditor of the type BezierPath, meaning it will be used when a GameObject with a BezierPath Component attached is selected.\r\n```cs\r\nusing UnityEngine;\r\nusing UnityEditor;\r\n\r\n[CustomEditor(typeof(BezierPath))]\r\npublic class BezierPathEditor : Editor\r\n{\r\n    private BezierPath bezierPath;\r\n}\r\n```\r\ngfgdfgdfg, rtuy.. ttuyu ...\r\n```cs\r\nprivate void DrawBezierPath()\r\n{\r\n    for (int bezierPointNumber = 0; bezierPointNumber < bezierPath.bezierPoints.Count - (bezierPath.closed ? 0 : 1); bezierPointNumber++)\r\n    {\r\n        for (int iteration = 0; iteration < bezierPath.bezierPoints[bezierPointNumber].iterations + 1; iteration++)\r\n            Handles.DrawLine(bezierPath.transform.TransformPoint(bezierPath.bezierPoints[bezierPointNumber].points[iteration]),\r\n                bezierPath.transform.TransformPoint(bezierPath.bezierPoints[bezierPointNumber].points[iteration + 1]));\r\n    }\r\n}\r\n```\r\n\r\n### Stay tuned!\r\nFor more guides blablablablablabla... Tobias Kullblikk",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}